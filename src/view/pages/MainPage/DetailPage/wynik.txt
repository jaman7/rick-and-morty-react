DetailPage.scss
.detail-page {
  max-width: 1600px;
  margin: 0 auto;
  padding: 2rem 1rem;
  background-color: var(--main-bg);
  color: var(--main-text-primary);
  display: flex;
  flex-direction: column;
  gap: 2rem;
}

.loading {
  text-align: center;
  font-size: 1.2rem;
  padding: 4rem 0;
  color: var(--main-text-secondary);
}


DetailPage.service.ts
import HttpService from '@/core/services/http/http.service';
import { ICharacter, IEpisode, ILocation } from '@/shared/types/character';
import { catchError, from, map, Observable, of } from 'rxjs';

export const api = 'https://rickandmortyapi.com/api';

const http = new HttpService();

export const getCharacterById = (id: string): Observable<ICharacter> => {
  return from(http.get<ICharacter>(`${api}/character/${id}`, {})).pipe(
    map((response) => response ?? {}),
    catchError((error) => {
      console.error('Error fetching character', error);
      return of(error);
    })
  );
};

export const getEpisodesByUrls = (urls: string[]): Observable<IEpisode[]> => {
  const episodeIds = urls.map((url) => url.split('/').pop()).join(',');
  return from(http.get<IEpisode[]>(`${api}/episode/${episodeIds}`, {})).pipe(
    map((response) => (Array.isArray(response) ? response : [response])),
    catchError((error) => {
      console.error('Error fetching episode', error);
      return of(error);
    })
  );
};

export const getLocationByUrl = (url: string): Observable<ILocation> => {
  return from(http.get<ILocation>(url, {})).pipe(
    map((response) => response),
    catchError((error) => {
      console.error('Error fetching character location', error);
      return of(error);
    })
  );
};

export const getCharactersByUrls = (urls: string[]): Observable<ICharacter[]> => {
  const ids = urls.map((url) => url.split('/').pop()).join(',');
  return from(http.get<ICharacter[]>(`${api}/character/${ids}`, {})).pipe(
    map((response) => (Array.isArray(response) ? response : [response])),
    catchError((error) => {
      console.error('Error fetching characters', error);
      return of(error);
    })
  );
};


DetailPage.tsx
import { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import { ICharacter, IEpisode } from '@/shared/types/character';
import { getCharacterById, getCharactersByUrls, getEpisodesByUrls, getLocationByUrl } from './DetailPage.service';
import CharacterInfo from './CharacterInfo/CharacterInfo';
import EpisodesTimeline from './EpisodesTimeline/EpisodesTimeline';
import RelatedCharacters from './RelatedCharacters/RelatedCharacters';
import CharacterHero from './CharacterHero/CharacterHero';
import { forkJoin, of, switchMap, tap } from 'rxjs';
import './DetailPage.scss';

const DetailPage = () => {
  const { id } = useParams();
  const [character, setCharacter] = useState<ICharacter | null>(null);
  const [episodes, setEpisodes] = useState<IEpisode[]>([]);
  const [related, setRelated] = useState<ICharacter[]>([]);

  useEffect(() => {
    if (!id) return;

    const subscription = getCharacterById(id)
      .pipe(
        tap((char) => setCharacter(char)),
        switchMap((char) => {
          const episode$ = getEpisodesByUrls(char.episode);
          const related$ = char.location?.url
            ? getLocationByUrl(char.location.url).pipe(
                switchMap((loc) => {
                  const urls = loc.residents.filter((url) => url !== char.url).slice(0, 6);
                  return urls.length ? getCharactersByUrls(urls) : of([]);
                })
              )
            : of([]);

          return forkJoin([episode$, related$]);
        })
      )
      .subscribe({
        next: ([ep, relatedChars]) => {
          setEpisodes(ep);
          setRelated(relatedChars);
        },
        error: (err) => console.error('DetailPage error', err),
      });

    return () => subscription.unsubscribe();
  }, [id]);
  if (!character) return <div className="loading">Loading...</div>;

  return (
    <div className="detail-page">
      <CharacterHero character={character ?? {}} />

      <CharacterInfo character={character ?? {}} />

      <EpisodesTimeline episodes={episodes ?? []} />

      <RelatedCharacters characters={related ?? []} />
    </div>
  );
};

export default DetailPage;


CharacterHero\CharacterHero.scss
@import "@scss/extend";
@import "@scss/mixins";

.character-hero {
  position: relative;
  display: flex;
  align-items: center;
  gap: 2rem;
  padding: 1rem;
  border-radius: 1rem;
  overflow: hidden;
  margin-bottom: 2rem;

  @extend %shared-box-shadow-big;

  img {
    max-width: 200px;
    border-radius: 1rem;
    box-shadow: 0 2px 8px rgb(0 0 0 / 10%);
    z-index: 2;
  }

  .character-hero__bg {
    content: "";
    position: absolute;
    inset: 0;

    @include linear-gradient(to right, var(--main-text-orange), var(--main-text-blue));

    background-size: 150% 150%;
    animation: hero-parallax 15s ease-in-out infinite;
    filter: blur(5px);
    z-index: 0;
  }

  .hero-info {
    flex: 1;
    z-index: 2;

    p {
      color: var(--main-text-secondary);
      font-size: 1rem;
      line-height: 1.6;
    }
  }
}

@keyframes hero-parallax {
  0%,
  100% {
    background-position: 0% 50%;
  }

  50% {
    background-position: 100% 50%;
  }
}


CharacterHero\CharacterHero.tsx
import { ICharacter } from '@/shared/types/character';
import './CharacterHero.scss';
import LazyImage from '@/shared/components/LazyImage/LazyImage';
import { motion } from 'framer-motion';

const CharacterHero = ({ character }: { character: ICharacter }) => {
  return (
    <motion.div className="character-hero" initial={{ opacity: 0, y: 40 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.6 }}>
      <div className="character-hero__bg" aria-hidden="true" />
      <LazyImage src={character.image} alt={character.name} />
      <div className="hero-info">
        <h1>{character.name}</h1>
        <div className={`status status--${character.status.toLowerCase()}`}>{character.status}</div>
        <p>
          <strong>Species:</strong> {character.species} {character.type ? `– ${character.type}` : ''}
          <br />
          <strong>Gender:</strong> {character.gender}
        </p>
      </div>
    </motion.div>
  );
};

export default CharacterHero;


CharacterInfo\CharacterInfo.scss
.character-info {
  margin-bottom: 2rem;

  ul {
    line-height: 1.8;

    li {
      font-size: 1rem;
      color: var(--main-text-primary);

      strong {
        color: var(--main-text-secondary);
      }
    }
  }
}


CharacterInfo\CharacterInfo.tsx
import { ICharacter } from '@/shared/types/character';
import './CharacterInfo.scss';

const CharacterInfo = ({ character }: { character: ICharacter }) => {
  return (
    <div className="character-info">
      <h3 className="page-title">Character Info</h3>
      <ul>
        <li>
          <strong>Species:</strong> {character.species}
        </li>
        {character.type && (
          <li>
            <strong>Type:</strong> {character.type}
          </li>
        )}
        <li>
          <strong>Gender:</strong> {character.gender}
        </li>
        <li>
          <strong>Status:</strong> {character.status}
        </li>
        <li>
          <strong>Origin:</strong> {character.origin?.name}
        </li>
        <li>
          <strong>Location:</strong> {character.location?.name}
        </li>
      </ul>
    </div>
  );
};

export default CharacterInfo;


EpisodesTimeline\EpisodesTimeline.scss
@import "@scss/mixins";
@import "@scss/extend";

.episodes-timeline {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  border-radius: 1rem;
  padding: 1rem 0.5rem;

  @extend %shared-box-shadow-big;

  .timeline {
    position: relative;
    margin: 2rem 0 0;
    padding-left: 2rem;
    list-style: none;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;

    &-container {
      display: flex;
      justify-content: center;
    }

    &-item {
      position: relative;

      &::before {
        content: "";
        position: absolute;
        top: 14px;
        left: -3px;
        width: 6px;
        height: 100%;

        @include linear-gradient(to bottom, var(--main-bg-blue), var(--main-bg-orange));
      }

      &:last-child::before {
        display: none;
      }
    }

    &-dot {
      position: absolute;
      left: -10px;
      top: 0;
      width: 20px;
      height: 20px;
      background-color: var(--main-bg-orange);
      border: 2px solid var(--main-bg-blue);
      border-radius: 50%;

      @extend %shared-box-shadow;

      z-index: 2;
    }

    &-title {
      color: var(--main-text-orange);
      font-size: 0.95rem;
    }

    &-episode {
      color: var(--main-text-blue);
    }

    &-date {
      color: var(--main-text-secondary);
      font-size: 0.85rem;
    }

    &-content {
      margin-left: 1rem;
    }

    &-header {
      font-weight: bold;
      color: var(--main-text-primary);
      display: flex;
      gap: 0.5rem;
      align-items: center;
      font-size: 0.95rem;
    }
  }
}


EpisodesTimeline\EpisodesTimeline.tsx
import { IEpisode } from '@/shared/types/character';
import './EpisodesTimeline.scss';

const EpisodesTimeline = ({ episodes }: { episodes: IEpisode[] }) => {
  return (
    <div className="episodes-timeline">
      <h3 className="page-title text-center">Episode Timeline</h3>
      <div className="timeline-container">
        <ul className="timeline">
          {episodes.map((ep) => (
            <li key={ep.id} className="timeline-item">
              <div className="timeline-dot" />
              <div className="timeline-content">
                <div className="timeline-header">
                  <span className="timeline-episode">{ep.episode}</span>
                  <span className="timeline-date">({ep.air_date})</span>
                </div>
                <div className="timeline-title">{ep.name}</div>
              </div>
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
};

export default EpisodesTimeline;


RelatedCharacters\RelatedCharacters.scss
.related-characters {
  margin-bottom: 2rem;

  .related-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 0.5rem;
  }

  .related-card {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-decoration: none;
    padding: 0.5rem;
    border: 1px solid var(--main-bg-orange);
    border-radius: 0.5rem;
    background-color: var(--main-bg-white);
    transition: transform 0.2s ease-in-out;
    gap: 0.5rem;

    &:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgb(0 0 0 / 15%);
    }

    img {
      border-radius: 0.5rem;
    }

    span {
      font-size: 0.9rem;
      color: var(--main-text-primary);
      text-align: center;
    }
  }
}


RelatedCharacters\RelatedCharacters.tsx
import { ICharacter } from '@/shared/types/character';
import { Link } from 'react-router-dom';
import './RelatedCharacters.scss';
import LazyImage from '@/shared/components/LazyImage/LazyImage';

const RelatedCharacters = ({ characters }: { characters: ICharacter[] }) => {
  return (
    <div className="related-characters">
      <h3 className="page-title mb-3">Other Characters from this Location</h3>
      <div className="related-grid">
        {characters.map((char) => (
          <Link to={`/character/${char.id}`} key={char.id} className="related-card">
            <LazyImage src={char.image} alt={char.name} />
            <span>{char.name}</span>
          </Link>
        ))}
      </div>
    </div>
  );
};

export default RelatedCharacters;


